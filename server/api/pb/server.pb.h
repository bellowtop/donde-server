// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pb_2fserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pb_2fserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pb_2fserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pb_2fserver_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pb_2fserver_2eproto;
namespace com {
namespace sekirocc {
namespace face_service {
class BatchDetectRequest;
struct BatchDetectRequestDefaultTypeInternal;
extern BatchDetectRequestDefaultTypeInternal _BatchDetectRequest_default_instance_;
class BatchDetectResponse;
struct BatchDetectResponseDefaultTypeInternal;
extern BatchDetectResponseDefaultTypeInternal _BatchDetectResponse_default_instance_;
class BoundingPoly;
struct BoundingPolyDefaultTypeInternal;
extern BoundingPolyDefaultTypeInternal _BoundingPoly_default_instance_;
class FaceDetectRequest;
struct FaceDetectRequestDefaultTypeInternal;
extern FaceDetectRequestDefaultTypeInternal _FaceDetectRequest_default_instance_;
class FaceDetectResponse;
struct FaceDetectResponseDefaultTypeInternal;
extern FaceDetectResponseDefaultTypeInternal _FaceDetectResponse_default_instance_;
class FaceFeature;
struct FaceFeatureDefaultTypeInternal;
extern FaceFeatureDefaultTypeInternal _FaceFeature_default_instance_;
class FaceObject;
struct FaceObjectDefaultTypeInternal;
extern FaceObjectDefaultTypeInternal _FaceObject_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ObjectInfo;
struct ObjectInfoDefaultTypeInternal;
extern ObjectInfoDefaultTypeInternal _ObjectInfo_default_instance_;
class Result;
struct ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class Size;
struct SizeDefaultTypeInternal;
extern SizeDefaultTypeInternal _Size_default_instance_;
class Vertex;
struct VertexDefaultTypeInternal;
extern VertexDefaultTypeInternal _Vertex_default_instance_;
}  // namespace face_service
}  // namespace sekirocc
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> ::com::sekirocc::face_service::BatchDetectRequest* Arena::CreateMaybeMessage<::com::sekirocc::face_service::BatchDetectRequest>(Arena*);
template<> ::com::sekirocc::face_service::BatchDetectResponse* Arena::CreateMaybeMessage<::com::sekirocc::face_service::BatchDetectResponse>(Arena*);
template<> ::com::sekirocc::face_service::BoundingPoly* Arena::CreateMaybeMessage<::com::sekirocc::face_service::BoundingPoly>(Arena*);
template<> ::com::sekirocc::face_service::FaceDetectRequest* Arena::CreateMaybeMessage<::com::sekirocc::face_service::FaceDetectRequest>(Arena*);
template<> ::com::sekirocc::face_service::FaceDetectResponse* Arena::CreateMaybeMessage<::com::sekirocc::face_service::FaceDetectResponse>(Arena*);
template<> ::com::sekirocc::face_service::FaceFeature* Arena::CreateMaybeMessage<::com::sekirocc::face_service::FaceFeature>(Arena*);
template<> ::com::sekirocc::face_service::FaceObject* Arena::CreateMaybeMessage<::com::sekirocc::face_service::FaceObject>(Arena*);
template<> ::com::sekirocc::face_service::Image* Arena::CreateMaybeMessage<::com::sekirocc::face_service::Image>(Arena*);
template<> ::com::sekirocc::face_service::ObjectInfo* Arena::CreateMaybeMessage<::com::sekirocc::face_service::ObjectInfo>(Arena*);
template<> ::com::sekirocc::face_service::Result* Arena::CreateMaybeMessage<::com::sekirocc::face_service::Result>(Arena*);
template<> ::com::sekirocc::face_service::Size* Arena::CreateMaybeMessage<::com::sekirocc::face_service::Size>(Arena*);
template<> ::com::sekirocc::face_service::Vertex* Arena::CreateMaybeMessage<::com::sekirocc::face_service::Vertex>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace com {
namespace sekirocc {
namespace face_service {

enum ImageFormat : int {
  IMAGE_UNKNOWN = 0,
  IMAGE_JPEG = 1,
  IMAGE_PNG = 2,
  IMAGE_BMP = 3,
  IMAGE_TIFF = 4,
  IMAGE_GIF = 5,
  ImageFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ImageFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ImageFormat_IsValid(int value);
constexpr ImageFormat ImageFormat_MIN = IMAGE_UNKNOWN;
constexpr ImageFormat ImageFormat_MAX = IMAGE_GIF;
constexpr int ImageFormat_ARRAYSIZE = ImageFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageFormat_descriptor();
template<typename T>
inline const std::string& ImageFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageFormat_descriptor(), enum_t_value);
}
inline bool ImageFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageFormat>(
    ImageFormat_descriptor(), name, value);
}
enum StatusCode : int {
  OK = 0,
  SERVER_ERROR = 10001,
  CLIENT_ERROR = 10101,
  FACE_NOT_FOUND = 10102,
  StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StatusCode_IsValid(int value);
constexpr StatusCode StatusCode_MIN = OK;
constexpr StatusCode StatusCode_MAX = FACE_NOT_FOUND;
constexpr int StatusCode_ARRAYSIZE = StatusCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusCode_descriptor();
template<typename T>
inline const std::string& StatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusCode_descriptor(), enum_t_value);
}
inline bool StatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatusCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusCode>(
    StatusCode_descriptor(), name, value);
}
// ===================================================================

class Vertex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.sekirocc.face_service.Vertex) */ {
 public:
  inline Vertex() : Vertex(nullptr) {}
  ~Vertex() override;
  explicit constexpr Vertex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vertex(const Vertex& from);
  Vertex(Vertex&& from) noexcept
    : Vertex() {
    *this = ::std::move(from);
  }

  inline Vertex& operator=(const Vertex& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vertex& operator=(Vertex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vertex& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vertex* internal_default_instance() {
    return reinterpret_cast<const Vertex*>(
               &_Vertex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vertex& a, Vertex& b) {
    a.Swap(&b);
  }
  inline void Swap(Vertex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vertex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vertex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vertex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vertex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vertex& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vertex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.sekirocc.face_service.Vertex";
  }
  protected:
  explicit Vertex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.sekirocc.face_service.Vertex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t x_;
  int32_t y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2fserver_2eproto;
};
// -------------------------------------------------------------------

class Size final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.sekirocc.face_service.Size) */ {
 public:
  inline Size() : Size(nullptr) {}
  ~Size() override;
  explicit constexpr Size(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Size(const Size& from);
  Size(Size&& from) noexcept
    : Size() {
    *this = ::std::move(from);
  }

  inline Size& operator=(const Size& from) {
    CopyFrom(from);
    return *this;
  }
  inline Size& operator=(Size&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Size& default_instance() {
    return *internal_default_instance();
  }
  static inline const Size* internal_default_instance() {
    return reinterpret_cast<const Size*>(
               &_Size_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Size& a, Size& b) {
    a.Swap(&b);
  }
  inline void Swap(Size* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Size* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Size* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Size>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Size& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Size& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Size* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.sekirocc.face_service.Size";
  }
  protected:
  explicit Size(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // int32 width = 1;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 2;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.sekirocc.face_service.Size)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t width_;
  int32_t height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2fserver_2eproto;
};
// -------------------------------------------------------------------

class BoundingPoly final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.sekirocc.face_service.BoundingPoly) */ {
 public:
  inline BoundingPoly() : BoundingPoly(nullptr) {}
  ~BoundingPoly() override;
  explicit constexpr BoundingPoly(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoundingPoly(const BoundingPoly& from);
  BoundingPoly(BoundingPoly&& from) noexcept
    : BoundingPoly() {
    *this = ::std::move(from);
  }

  inline BoundingPoly& operator=(const BoundingPoly& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundingPoly& operator=(BoundingPoly&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoundingPoly& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoundingPoly* internal_default_instance() {
    return reinterpret_cast<const BoundingPoly*>(
               &_BoundingPoly_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BoundingPoly& a, BoundingPoly& b) {
    a.Swap(&b);
  }
  inline void Swap(BoundingPoly* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoundingPoly* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoundingPoly* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoundingPoly>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoundingPoly& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BoundingPoly& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundingPoly* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.sekirocc.face_service.BoundingPoly";
  }
  protected:
  explicit BoundingPoly(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
  };
  // repeated .com.sekirocc.face_service.Vertex vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::com::sekirocc::face_service::Vertex* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Vertex >*
      mutable_vertices();
  private:
  const ::com::sekirocc::face_service::Vertex& _internal_vertices(int index) const;
  ::com::sekirocc::face_service::Vertex* _internal_add_vertices();
  public:
  const ::com::sekirocc::face_service::Vertex& vertices(int index) const;
  ::com::sekirocc::face_service::Vertex* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Vertex >&
      vertices() const;

  // @@protoc_insertion_point(class_scope:com.sekirocc.face_service.BoundingPoly)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Vertex > vertices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2fserver_2eproto;
};
// -------------------------------------------------------------------

class Image final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.sekirocc.face_service.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() override;
  explicit constexpr Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Image& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Image& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.sekirocc.face_service.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kFormatFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .com.sekirocc.face_service.ImageFormat format = 1;
  void clear_format();
  ::com::sekirocc::face_service::ImageFormat format() const;
  void set_format(::com::sekirocc::face_service::ImageFormat value);
  private:
  ::com::sekirocc::face_service::ImageFormat _internal_format() const;
  void _internal_set_format(::com::sekirocc::face_service::ImageFormat value);
  public:

  // @@protoc_insertion_point(class_scope:com.sekirocc.face_service.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int format_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FaceDetectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.sekirocc.face_service.FaceDetectRequest) */ {
 public:
  inline FaceDetectRequest() : FaceDetectRequest(nullptr) {}
  ~FaceDetectRequest() override;
  explicit constexpr FaceDetectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceDetectRequest(const FaceDetectRequest& from);
  FaceDetectRequest(FaceDetectRequest&& from) noexcept
    : FaceDetectRequest() {
    *this = ::std::move(from);
  }

  inline FaceDetectRequest& operator=(const FaceDetectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceDetectRequest& operator=(FaceDetectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceDetectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceDetectRequest* internal_default_instance() {
    return reinterpret_cast<const FaceDetectRequest*>(
               &_FaceDetectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FaceDetectRequest& a, FaceDetectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceDetectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceDetectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceDetectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceDetectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceDetectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FaceDetectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceDetectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.sekirocc.face_service.FaceDetectRequest";
  }
  protected:
  explicit FaceDetectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 1,
  };
  // .com.sekirocc.face_service.Image image = 1;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::com::sekirocc::face_service::Image& image() const;
  PROTOBUF_NODISCARD ::com::sekirocc::face_service::Image* release_image();
  ::com::sekirocc::face_service::Image* mutable_image();
  void set_allocated_image(::com::sekirocc::face_service::Image* image);
  private:
  const ::com::sekirocc::face_service::Image& _internal_image() const;
  ::com::sekirocc::face_service::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::com::sekirocc::face_service::Image* image);
  ::com::sekirocc::face_service::Image* unsafe_arena_release_image();

  // @@protoc_insertion_point(class_scope:com.sekirocc.face_service.FaceDetectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::com::sekirocc::face_service::Image* image_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2fserver_2eproto;
};
// -------------------------------------------------------------------

class BatchDetectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.sekirocc.face_service.BatchDetectRequest) */ {
 public:
  inline BatchDetectRequest() : BatchDetectRequest(nullptr) {}
  ~BatchDetectRequest() override;
  explicit constexpr BatchDetectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchDetectRequest(const BatchDetectRequest& from);
  BatchDetectRequest(BatchDetectRequest&& from) noexcept
    : BatchDetectRequest() {
    *this = ::std::move(from);
  }

  inline BatchDetectRequest& operator=(const BatchDetectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchDetectRequest& operator=(BatchDetectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchDetectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchDetectRequest* internal_default_instance() {
    return reinterpret_cast<const BatchDetectRequest*>(
               &_BatchDetectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BatchDetectRequest& a, BatchDetectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchDetectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchDetectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchDetectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchDetectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchDetectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchDetectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchDetectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.sekirocc.face_service.BatchDetectRequest";
  }
  protected:
  explicit BatchDetectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .com.sekirocc.face_service.FaceDetectRequest requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::com::sekirocc::face_service::FaceDetectRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::FaceDetectRequest >*
      mutable_requests();
  private:
  const ::com::sekirocc::face_service::FaceDetectRequest& _internal_requests(int index) const;
  ::com::sekirocc::face_service::FaceDetectRequest* _internal_add_requests();
  public:
  const ::com::sekirocc::face_service::FaceDetectRequest& requests(int index) const;
  ::com::sekirocc::face_service::FaceDetectRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::FaceDetectRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:com.sekirocc.face_service.BatchDetectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::FaceDetectRequest > requests_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2fserver_2eproto;
};
// -------------------------------------------------------------------

class Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.sekirocc.face_service.Result) */ {
 public:
  inline Result() : Result(nullptr) {}
  ~Result() override;
  explicit constexpr Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Result(const Result& from);
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.sekirocc.face_service.Result";
  }
  protected:
  explicit Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kCodeFieldNumber = 1,
    kStatusFieldNumber = 3,
  };
  // string error = 2;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // .com.sekirocc.face_service.StatusCode status = 3;
  void clear_status();
  ::com::sekirocc::face_service::StatusCode status() const;
  void set_status(::com::sekirocc::face_service::StatusCode value);
  private:
  ::com::sekirocc::face_service::StatusCode _internal_status() const;
  void _internal_set_status(::com::sekirocc::face_service::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:com.sekirocc.face_service.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  int32_t code_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FaceFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.sekirocc.face_service.FaceFeature) */ {
 public:
  inline FaceFeature() : FaceFeature(nullptr) {}
  ~FaceFeature() override;
  explicit constexpr FaceFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceFeature(const FaceFeature& from);
  FaceFeature(FaceFeature&& from) noexcept
    : FaceFeature() {
    *this = ::std::move(from);
  }

  inline FaceFeature& operator=(const FaceFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceFeature& operator=(FaceFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceFeature* internal_default_instance() {
    return reinterpret_cast<const FaceFeature*>(
               &_FaceFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FaceFeature& a, FaceFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FaceFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.sekirocc.face_service.FaceFeature";
  }
  protected:
  explicit FaceFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // bytes blob = 1;
  void clear_blob();
  const std::string& blob() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blob(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blob();
  PROTOBUF_NODISCARD std::string* release_blob();
  void set_allocated_blob(std::string* blob);
  private:
  const std::string& _internal_blob() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blob(const std::string& value);
  std::string* _internal_mutable_blob();
  public:

  // int32 version = 2;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.sekirocc.face_service.FaceFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blob_;
  int32_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FaceObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.sekirocc.face_service.FaceObject) */ {
 public:
  inline FaceObject() : FaceObject(nullptr) {}
  ~FaceObject() override;
  explicit constexpr FaceObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceObject(const FaceObject& from);
  FaceObject(FaceObject&& from) noexcept
    : FaceObject() {
    *this = ::std::move(from);
  }

  inline FaceObject& operator=(const FaceObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceObject& operator=(FaceObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceObject* internal_default_instance() {
    return reinterpret_cast<const FaceObject*>(
               &_FaceObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FaceObject& a, FaceObject& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FaceObject& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.sekirocc.face_service.FaceObject";
  }
  protected:
  explicit FaceObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLandmarksFieldNumber = 3,
    kRectangleFieldNumber = 2,
    kFeatureFieldNumber = 5,
    kQualityFieldNumber = 1,
    kFaceScoreFieldNumber = 4,
  };
  // repeated .com.sekirocc.face_service.Vertex landmarks = 3;
  int landmarks_size() const;
  private:
  int _internal_landmarks_size() const;
  public:
  void clear_landmarks();
  ::com::sekirocc::face_service::Vertex* mutable_landmarks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Vertex >*
      mutable_landmarks();
  private:
  const ::com::sekirocc::face_service::Vertex& _internal_landmarks(int index) const;
  ::com::sekirocc::face_service::Vertex* _internal_add_landmarks();
  public:
  const ::com::sekirocc::face_service::Vertex& landmarks(int index) const;
  ::com::sekirocc::face_service::Vertex* add_landmarks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Vertex >&
      landmarks() const;

  // .com.sekirocc.face_service.BoundingPoly rectangle = 2;
  bool has_rectangle() const;
  private:
  bool _internal_has_rectangle() const;
  public:
  void clear_rectangle();
  const ::com::sekirocc::face_service::BoundingPoly& rectangle() const;
  PROTOBUF_NODISCARD ::com::sekirocc::face_service::BoundingPoly* release_rectangle();
  ::com::sekirocc::face_service::BoundingPoly* mutable_rectangle();
  void set_allocated_rectangle(::com::sekirocc::face_service::BoundingPoly* rectangle);
  private:
  const ::com::sekirocc::face_service::BoundingPoly& _internal_rectangle() const;
  ::com::sekirocc::face_service::BoundingPoly* _internal_mutable_rectangle();
  public:
  void unsafe_arena_set_allocated_rectangle(
      ::com::sekirocc::face_service::BoundingPoly* rectangle);
  ::com::sekirocc::face_service::BoundingPoly* unsafe_arena_release_rectangle();

  // .com.sekirocc.face_service.FaceFeature feature = 5;
  bool has_feature() const;
  private:
  bool _internal_has_feature() const;
  public:
  void clear_feature();
  const ::com::sekirocc::face_service::FaceFeature& feature() const;
  PROTOBUF_NODISCARD ::com::sekirocc::face_service::FaceFeature* release_feature();
  ::com::sekirocc::face_service::FaceFeature* mutable_feature();
  void set_allocated_feature(::com::sekirocc::face_service::FaceFeature* feature);
  private:
  const ::com::sekirocc::face_service::FaceFeature& _internal_feature() const;
  ::com::sekirocc::face_service::FaceFeature* _internal_mutable_feature();
  public:
  void unsafe_arena_set_allocated_feature(
      ::com::sekirocc::face_service::FaceFeature* feature);
  ::com::sekirocc::face_service::FaceFeature* unsafe_arena_release_feature();

  // float quality = 1;
  void clear_quality();
  float quality() const;
  void set_quality(float value);
  private:
  float _internal_quality() const;
  void _internal_set_quality(float value);
  public:

  // float face_score = 4;
  void clear_face_score();
  float face_score() const;
  void set_face_score(float value);
  private:
  float _internal_face_score() const;
  void _internal_set_face_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:com.sekirocc.face_service.FaceObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Vertex > landmarks_;
  ::com::sekirocc::face_service::BoundingPoly* rectangle_;
  ::com::sekirocc::face_service::FaceFeature* feature_;
  float quality_;
  float face_score_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2fserver_2eproto;
};
// -------------------------------------------------------------------

class ObjectInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.sekirocc.face_service.ObjectInfo) */ {
 public:
  inline ObjectInfo() : ObjectInfo(nullptr) {}
  ~ObjectInfo() override;
  explicit constexpr ObjectInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectInfo(const ObjectInfo& from);
  ObjectInfo(ObjectInfo&& from) noexcept
    : ObjectInfo() {
    *this = ::std::move(from);
  }

  inline ObjectInfo& operator=(const ObjectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectInfo& operator=(ObjectInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectInfo* internal_default_instance() {
    return reinterpret_cast<const ObjectInfo*>(
               &_ObjectInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ObjectInfo& a, ObjectInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.sekirocc.face_service.ObjectInfo";
  }
  protected:
  explicit ObjectInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFaceFieldNumber = 1,
  };
  // .com.sekirocc.face_service.FaceObject face = 1;
  bool has_face() const;
  private:
  bool _internal_has_face() const;
  public:
  void clear_face();
  const ::com::sekirocc::face_service::FaceObject& face() const;
  PROTOBUF_NODISCARD ::com::sekirocc::face_service::FaceObject* release_face();
  ::com::sekirocc::face_service::FaceObject* mutable_face();
  void set_allocated_face(::com::sekirocc::face_service::FaceObject* face);
  private:
  const ::com::sekirocc::face_service::FaceObject& _internal_face() const;
  ::com::sekirocc::face_service::FaceObject* _internal_mutable_face();
  public:
  void unsafe_arena_set_allocated_face(
      ::com::sekirocc::face_service::FaceObject* face);
  ::com::sekirocc::face_service::FaceObject* unsafe_arena_release_face();

  // @@protoc_insertion_point(class_scope:com.sekirocc.face_service.ObjectInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::com::sekirocc::face_service::FaceObject* face_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FaceDetectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.sekirocc.face_service.FaceDetectResponse) */ {
 public:
  inline FaceDetectResponse() : FaceDetectResponse(nullptr) {}
  ~FaceDetectResponse() override;
  explicit constexpr FaceDetectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceDetectResponse(const FaceDetectResponse& from);
  FaceDetectResponse(FaceDetectResponse&& from) noexcept
    : FaceDetectResponse() {
    *this = ::std::move(from);
  }

  inline FaceDetectResponse& operator=(const FaceDetectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceDetectResponse& operator=(FaceDetectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceDetectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceDetectResponse* internal_default_instance() {
    return reinterpret_cast<const FaceDetectResponse*>(
               &_FaceDetectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FaceDetectResponse& a, FaceDetectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceDetectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceDetectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceDetectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceDetectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceDetectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FaceDetectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceDetectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.sekirocc.face_service.FaceDetectResponse";
  }
  protected:
  explicit FaceDetectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFaceInfoFieldNumber = 1,
  };
  // repeated .com.sekirocc.face_service.ObjectInfo face_info = 1;
  int face_info_size() const;
  private:
  int _internal_face_info_size() const;
  public:
  void clear_face_info();
  ::com::sekirocc::face_service::ObjectInfo* mutable_face_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::ObjectInfo >*
      mutable_face_info();
  private:
  const ::com::sekirocc::face_service::ObjectInfo& _internal_face_info(int index) const;
  ::com::sekirocc::face_service::ObjectInfo* _internal_add_face_info();
  public:
  const ::com::sekirocc::face_service::ObjectInfo& face_info(int index) const;
  ::com::sekirocc::face_service::ObjectInfo* add_face_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::ObjectInfo >&
      face_info() const;

  // @@protoc_insertion_point(class_scope:com.sekirocc.face_service.FaceDetectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::ObjectInfo > face_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2fserver_2eproto;
};
// -------------------------------------------------------------------

class BatchDetectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.sekirocc.face_service.BatchDetectResponse) */ {
 public:
  inline BatchDetectResponse() : BatchDetectResponse(nullptr) {}
  ~BatchDetectResponse() override;
  explicit constexpr BatchDetectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchDetectResponse(const BatchDetectResponse& from);
  BatchDetectResponse(BatchDetectResponse&& from) noexcept
    : BatchDetectResponse() {
    *this = ::std::move(from);
  }

  inline BatchDetectResponse& operator=(const BatchDetectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchDetectResponse& operator=(BatchDetectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchDetectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchDetectResponse* internal_default_instance() {
    return reinterpret_cast<const BatchDetectResponse*>(
               &_BatchDetectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BatchDetectResponse& a, BatchDetectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchDetectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchDetectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchDetectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchDetectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchDetectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchDetectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchDetectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.sekirocc.face_service.BatchDetectResponse";
  }
  protected:
  explicit BatchDetectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
    kResponsesFieldNumber = 2,
  };
  // repeated .com.sekirocc.face_service.Result results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::com::sekirocc::face_service::Result* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Result >*
      mutable_results();
  private:
  const ::com::sekirocc::face_service::Result& _internal_results(int index) const;
  ::com::sekirocc::face_service::Result* _internal_add_results();
  public:
  const ::com::sekirocc::face_service::Result& results(int index) const;
  ::com::sekirocc::face_service::Result* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Result >&
      results() const;

  // repeated .com.sekirocc.face_service.FaceDetectResponse responses = 2;
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::com::sekirocc::face_service::FaceDetectResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::FaceDetectResponse >*
      mutable_responses();
  private:
  const ::com::sekirocc::face_service::FaceDetectResponse& _internal_responses(int index) const;
  ::com::sekirocc::face_service::FaceDetectResponse* _internal_add_responses();
  public:
  const ::com::sekirocc::face_service::FaceDetectResponse& responses(int index) const;
  ::com::sekirocc::face_service::FaceDetectResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::FaceDetectResponse >&
      responses() const;

  // @@protoc_insertion_point(class_scope:com.sekirocc.face_service.BatchDetectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Result > results_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::FaceDetectResponse > responses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2fserver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vertex

// int32 x = 1;
inline void Vertex::clear_x() {
  x_ = 0;
}
inline int32_t Vertex::_internal_x() const {
  return x_;
}
inline int32_t Vertex::x() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.Vertex.x)
  return _internal_x();
}
inline void Vertex::_internal_set_x(int32_t value) {
  
  x_ = value;
}
inline void Vertex::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:com.sekirocc.face_service.Vertex.x)
}

// int32 y = 2;
inline void Vertex::clear_y() {
  y_ = 0;
}
inline int32_t Vertex::_internal_y() const {
  return y_;
}
inline int32_t Vertex::y() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.Vertex.y)
  return _internal_y();
}
inline void Vertex::_internal_set_y(int32_t value) {
  
  y_ = value;
}
inline void Vertex::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:com.sekirocc.face_service.Vertex.y)
}

// -------------------------------------------------------------------

// Size

// int32 width = 1;
inline void Size::clear_width() {
  width_ = 0;
}
inline int32_t Size::_internal_width() const {
  return width_;
}
inline int32_t Size::width() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.Size.width)
  return _internal_width();
}
inline void Size::_internal_set_width(int32_t value) {
  
  width_ = value;
}
inline void Size::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:com.sekirocc.face_service.Size.width)
}

// int32 height = 2;
inline void Size::clear_height() {
  height_ = 0;
}
inline int32_t Size::_internal_height() const {
  return height_;
}
inline int32_t Size::height() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.Size.height)
  return _internal_height();
}
inline void Size::_internal_set_height(int32_t value) {
  
  height_ = value;
}
inline void Size::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:com.sekirocc.face_service.Size.height)
}

// -------------------------------------------------------------------

// BoundingPoly

// repeated .com.sekirocc.face_service.Vertex vertices = 1;
inline int BoundingPoly::_internal_vertices_size() const {
  return vertices_.size();
}
inline int BoundingPoly::vertices_size() const {
  return _internal_vertices_size();
}
inline void BoundingPoly::clear_vertices() {
  vertices_.Clear();
}
inline ::com::sekirocc::face_service::Vertex* BoundingPoly::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:com.sekirocc.face_service.BoundingPoly.vertices)
  return vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Vertex >*
BoundingPoly::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:com.sekirocc.face_service.BoundingPoly.vertices)
  return &vertices_;
}
inline const ::com::sekirocc::face_service::Vertex& BoundingPoly::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline const ::com::sekirocc::face_service::Vertex& BoundingPoly::vertices(int index) const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.BoundingPoly.vertices)
  return _internal_vertices(index);
}
inline ::com::sekirocc::face_service::Vertex* BoundingPoly::_internal_add_vertices() {
  return vertices_.Add();
}
inline ::com::sekirocc::face_service::Vertex* BoundingPoly::add_vertices() {
  ::com::sekirocc::face_service::Vertex* _add = _internal_add_vertices();
  // @@protoc_insertion_point(field_add:com.sekirocc.face_service.BoundingPoly.vertices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Vertex >&
BoundingPoly::vertices() const {
  // @@protoc_insertion_point(field_list:com.sekirocc.face_service.BoundingPoly.vertices)
  return vertices_;
}

// -------------------------------------------------------------------

// Image

// .com.sekirocc.face_service.ImageFormat format = 1;
inline void Image::clear_format() {
  format_ = 0;
}
inline ::com::sekirocc::face_service::ImageFormat Image::_internal_format() const {
  return static_cast< ::com::sekirocc::face_service::ImageFormat >(format_);
}
inline ::com::sekirocc::face_service::ImageFormat Image::format() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.Image.format)
  return _internal_format();
}
inline void Image::_internal_set_format(::com::sekirocc::face_service::ImageFormat value) {
  
  format_ = value;
}
inline void Image::set_format(::com::sekirocc::face_service::ImageFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:com.sekirocc.face_service.Image.format)
}

// bytes data = 2;
inline void Image::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Image::data() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.Image.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.sekirocc.face_service.Image.data)
}
inline std::string* Image::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:com.sekirocc.face_service.Image.data)
  return _s;
}
inline const std::string& Image::_internal_data() const {
  return data_.Get();
}
inline void Image::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Image::release_data() {
  // @@protoc_insertion_point(field_release:com.sekirocc.face_service.Image.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Image::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.sekirocc.face_service.Image.data)
}

// -------------------------------------------------------------------

// FaceDetectRequest

// .com.sekirocc.face_service.Image image = 1;
inline bool FaceDetectRequest::_internal_has_image() const {
  return this != internal_default_instance() && image_ != nullptr;
}
inline bool FaceDetectRequest::has_image() const {
  return _internal_has_image();
}
inline void FaceDetectRequest::clear_image() {
  if (GetArenaForAllocation() == nullptr && image_ != nullptr) {
    delete image_;
  }
  image_ = nullptr;
}
inline const ::com::sekirocc::face_service::Image& FaceDetectRequest::_internal_image() const {
  const ::com::sekirocc::face_service::Image* p = image_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::sekirocc::face_service::Image&>(
      ::com::sekirocc::face_service::_Image_default_instance_);
}
inline const ::com::sekirocc::face_service::Image& FaceDetectRequest::image() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.FaceDetectRequest.image)
  return _internal_image();
}
inline void FaceDetectRequest::unsafe_arena_set_allocated_image(
    ::com::sekirocc::face_service::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_);
  }
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.sekirocc.face_service.FaceDetectRequest.image)
}
inline ::com::sekirocc::face_service::Image* FaceDetectRequest::release_image() {
  
  ::com::sekirocc::face_service::Image* temp = image_;
  image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::sekirocc::face_service::Image* FaceDetectRequest::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:com.sekirocc.face_service.FaceDetectRequest.image)
  
  ::com::sekirocc::face_service::Image* temp = image_;
  image_ = nullptr;
  return temp;
}
inline ::com::sekirocc::face_service::Image* FaceDetectRequest::_internal_mutable_image() {
  
  if (image_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::sekirocc::face_service::Image>(GetArenaForAllocation());
    image_ = p;
  }
  return image_;
}
inline ::com::sekirocc::face_service::Image* FaceDetectRequest::mutable_image() {
  ::com::sekirocc::face_service::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:com.sekirocc.face_service.FaceDetectRequest.image)
  return _msg;
}
inline void FaceDetectRequest::set_allocated_image(::com::sekirocc::face_service::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::com::sekirocc::face_service::Image>::GetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:com.sekirocc.face_service.FaceDetectRequest.image)
}

// -------------------------------------------------------------------

// BatchDetectRequest

// repeated .com.sekirocc.face_service.FaceDetectRequest requests = 1;
inline int BatchDetectRequest::_internal_requests_size() const {
  return requests_.size();
}
inline int BatchDetectRequest::requests_size() const {
  return _internal_requests_size();
}
inline void BatchDetectRequest::clear_requests() {
  requests_.Clear();
}
inline ::com::sekirocc::face_service::FaceDetectRequest* BatchDetectRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:com.sekirocc.face_service.BatchDetectRequest.requests)
  return requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::FaceDetectRequest >*
BatchDetectRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:com.sekirocc.face_service.BatchDetectRequest.requests)
  return &requests_;
}
inline const ::com::sekirocc::face_service::FaceDetectRequest& BatchDetectRequest::_internal_requests(int index) const {
  return requests_.Get(index);
}
inline const ::com::sekirocc::face_service::FaceDetectRequest& BatchDetectRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.BatchDetectRequest.requests)
  return _internal_requests(index);
}
inline ::com::sekirocc::face_service::FaceDetectRequest* BatchDetectRequest::_internal_add_requests() {
  return requests_.Add();
}
inline ::com::sekirocc::face_service::FaceDetectRequest* BatchDetectRequest::add_requests() {
  ::com::sekirocc::face_service::FaceDetectRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:com.sekirocc.face_service.BatchDetectRequest.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::FaceDetectRequest >&
BatchDetectRequest::requests() const {
  // @@protoc_insertion_point(field_list:com.sekirocc.face_service.BatchDetectRequest.requests)
  return requests_;
}

// -------------------------------------------------------------------

// Result

// int32 code = 1;
inline void Result::clear_code() {
  code_ = 0;
}
inline int32_t Result::_internal_code() const {
  return code_;
}
inline int32_t Result::code() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.Result.code)
  return _internal_code();
}
inline void Result::_internal_set_code(int32_t value) {
  
  code_ = value;
}
inline void Result::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:com.sekirocc.face_service.Result.code)
}

// string error = 2;
inline void Result::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& Result::error() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.Result.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Result::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.sekirocc.face_service.Result.error)
}
inline std::string* Result::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.sekirocc.face_service.Result.error)
  return _s;
}
inline const std::string& Result::_internal_error() const {
  return error_.Get();
}
inline void Result::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Result::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Result::release_error() {
  // @@protoc_insertion_point(field_release:com.sekirocc.face_service.Result.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Result::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.sekirocc.face_service.Result.error)
}

// .com.sekirocc.face_service.StatusCode status = 3;
inline void Result::clear_status() {
  status_ = 0;
}
inline ::com::sekirocc::face_service::StatusCode Result::_internal_status() const {
  return static_cast< ::com::sekirocc::face_service::StatusCode >(status_);
}
inline ::com::sekirocc::face_service::StatusCode Result::status() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.Result.status)
  return _internal_status();
}
inline void Result::_internal_set_status(::com::sekirocc::face_service::StatusCode value) {
  
  status_ = value;
}
inline void Result::set_status(::com::sekirocc::face_service::StatusCode value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.sekirocc.face_service.Result.status)
}

// -------------------------------------------------------------------

// FaceFeature

// bytes blob = 1;
inline void FaceFeature::clear_blob() {
  blob_.ClearToEmpty();
}
inline const std::string& FaceFeature::blob() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.FaceFeature.blob)
  return _internal_blob();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FaceFeature::set_blob(ArgT0&& arg0, ArgT... args) {
 
 blob_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.sekirocc.face_service.FaceFeature.blob)
}
inline std::string* FaceFeature::mutable_blob() {
  std::string* _s = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:com.sekirocc.face_service.FaceFeature.blob)
  return _s;
}
inline const std::string& FaceFeature::_internal_blob() const {
  return blob_.Get();
}
inline void FaceFeature::_internal_set_blob(const std::string& value) {
  
  blob_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FaceFeature::_internal_mutable_blob() {
  
  return blob_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FaceFeature::release_blob() {
  // @@protoc_insertion_point(field_release:com.sekirocc.face_service.FaceFeature.blob)
  return blob_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FaceFeature::set_allocated_blob(std::string* blob) {
  if (blob != nullptr) {
    
  } else {
    
  }
  blob_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blob,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (blob_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.sekirocc.face_service.FaceFeature.blob)
}

// int32 version = 2;
inline void FaceFeature::clear_version() {
  version_ = 0;
}
inline int32_t FaceFeature::_internal_version() const {
  return version_;
}
inline int32_t FaceFeature::version() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.FaceFeature.version)
  return _internal_version();
}
inline void FaceFeature::_internal_set_version(int32_t value) {
  
  version_ = value;
}
inline void FaceFeature::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:com.sekirocc.face_service.FaceFeature.version)
}

// -------------------------------------------------------------------

// FaceObject

// float quality = 1;
inline void FaceObject::clear_quality() {
  quality_ = 0;
}
inline float FaceObject::_internal_quality() const {
  return quality_;
}
inline float FaceObject::quality() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.FaceObject.quality)
  return _internal_quality();
}
inline void FaceObject::_internal_set_quality(float value) {
  
  quality_ = value;
}
inline void FaceObject::set_quality(float value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:com.sekirocc.face_service.FaceObject.quality)
}

// .com.sekirocc.face_service.BoundingPoly rectangle = 2;
inline bool FaceObject::_internal_has_rectangle() const {
  return this != internal_default_instance() && rectangle_ != nullptr;
}
inline bool FaceObject::has_rectangle() const {
  return _internal_has_rectangle();
}
inline void FaceObject::clear_rectangle() {
  if (GetArenaForAllocation() == nullptr && rectangle_ != nullptr) {
    delete rectangle_;
  }
  rectangle_ = nullptr;
}
inline const ::com::sekirocc::face_service::BoundingPoly& FaceObject::_internal_rectangle() const {
  const ::com::sekirocc::face_service::BoundingPoly* p = rectangle_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::sekirocc::face_service::BoundingPoly&>(
      ::com::sekirocc::face_service::_BoundingPoly_default_instance_);
}
inline const ::com::sekirocc::face_service::BoundingPoly& FaceObject::rectangle() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.FaceObject.rectangle)
  return _internal_rectangle();
}
inline void FaceObject::unsafe_arena_set_allocated_rectangle(
    ::com::sekirocc::face_service::BoundingPoly* rectangle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rectangle_);
  }
  rectangle_ = rectangle;
  if (rectangle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.sekirocc.face_service.FaceObject.rectangle)
}
inline ::com::sekirocc::face_service::BoundingPoly* FaceObject::release_rectangle() {
  
  ::com::sekirocc::face_service::BoundingPoly* temp = rectangle_;
  rectangle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::sekirocc::face_service::BoundingPoly* FaceObject::unsafe_arena_release_rectangle() {
  // @@protoc_insertion_point(field_release:com.sekirocc.face_service.FaceObject.rectangle)
  
  ::com::sekirocc::face_service::BoundingPoly* temp = rectangle_;
  rectangle_ = nullptr;
  return temp;
}
inline ::com::sekirocc::face_service::BoundingPoly* FaceObject::_internal_mutable_rectangle() {
  
  if (rectangle_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::sekirocc::face_service::BoundingPoly>(GetArenaForAllocation());
    rectangle_ = p;
  }
  return rectangle_;
}
inline ::com::sekirocc::face_service::BoundingPoly* FaceObject::mutable_rectangle() {
  ::com::sekirocc::face_service::BoundingPoly* _msg = _internal_mutable_rectangle();
  // @@protoc_insertion_point(field_mutable:com.sekirocc.face_service.FaceObject.rectangle)
  return _msg;
}
inline void FaceObject::set_allocated_rectangle(::com::sekirocc::face_service::BoundingPoly* rectangle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rectangle_;
  }
  if (rectangle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::com::sekirocc::face_service::BoundingPoly>::GetOwningArena(rectangle);
    if (message_arena != submessage_arena) {
      rectangle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rectangle, submessage_arena);
    }
    
  } else {
    
  }
  rectangle_ = rectangle;
  // @@protoc_insertion_point(field_set_allocated:com.sekirocc.face_service.FaceObject.rectangle)
}

// repeated .com.sekirocc.face_service.Vertex landmarks = 3;
inline int FaceObject::_internal_landmarks_size() const {
  return landmarks_.size();
}
inline int FaceObject::landmarks_size() const {
  return _internal_landmarks_size();
}
inline void FaceObject::clear_landmarks() {
  landmarks_.Clear();
}
inline ::com::sekirocc::face_service::Vertex* FaceObject::mutable_landmarks(int index) {
  // @@protoc_insertion_point(field_mutable:com.sekirocc.face_service.FaceObject.landmarks)
  return landmarks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Vertex >*
FaceObject::mutable_landmarks() {
  // @@protoc_insertion_point(field_mutable_list:com.sekirocc.face_service.FaceObject.landmarks)
  return &landmarks_;
}
inline const ::com::sekirocc::face_service::Vertex& FaceObject::_internal_landmarks(int index) const {
  return landmarks_.Get(index);
}
inline const ::com::sekirocc::face_service::Vertex& FaceObject::landmarks(int index) const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.FaceObject.landmarks)
  return _internal_landmarks(index);
}
inline ::com::sekirocc::face_service::Vertex* FaceObject::_internal_add_landmarks() {
  return landmarks_.Add();
}
inline ::com::sekirocc::face_service::Vertex* FaceObject::add_landmarks() {
  ::com::sekirocc::face_service::Vertex* _add = _internal_add_landmarks();
  // @@protoc_insertion_point(field_add:com.sekirocc.face_service.FaceObject.landmarks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Vertex >&
FaceObject::landmarks() const {
  // @@protoc_insertion_point(field_list:com.sekirocc.face_service.FaceObject.landmarks)
  return landmarks_;
}

// float face_score = 4;
inline void FaceObject::clear_face_score() {
  face_score_ = 0;
}
inline float FaceObject::_internal_face_score() const {
  return face_score_;
}
inline float FaceObject::face_score() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.FaceObject.face_score)
  return _internal_face_score();
}
inline void FaceObject::_internal_set_face_score(float value) {
  
  face_score_ = value;
}
inline void FaceObject::set_face_score(float value) {
  _internal_set_face_score(value);
  // @@protoc_insertion_point(field_set:com.sekirocc.face_service.FaceObject.face_score)
}

// .com.sekirocc.face_service.FaceFeature feature = 5;
inline bool FaceObject::_internal_has_feature() const {
  return this != internal_default_instance() && feature_ != nullptr;
}
inline bool FaceObject::has_feature() const {
  return _internal_has_feature();
}
inline void FaceObject::clear_feature() {
  if (GetArenaForAllocation() == nullptr && feature_ != nullptr) {
    delete feature_;
  }
  feature_ = nullptr;
}
inline const ::com::sekirocc::face_service::FaceFeature& FaceObject::_internal_feature() const {
  const ::com::sekirocc::face_service::FaceFeature* p = feature_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::sekirocc::face_service::FaceFeature&>(
      ::com::sekirocc::face_service::_FaceFeature_default_instance_);
}
inline const ::com::sekirocc::face_service::FaceFeature& FaceObject::feature() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.FaceObject.feature)
  return _internal_feature();
}
inline void FaceObject::unsafe_arena_set_allocated_feature(
    ::com::sekirocc::face_service::FaceFeature* feature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feature_);
  }
  feature_ = feature;
  if (feature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.sekirocc.face_service.FaceObject.feature)
}
inline ::com::sekirocc::face_service::FaceFeature* FaceObject::release_feature() {
  
  ::com::sekirocc::face_service::FaceFeature* temp = feature_;
  feature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::sekirocc::face_service::FaceFeature* FaceObject::unsafe_arena_release_feature() {
  // @@protoc_insertion_point(field_release:com.sekirocc.face_service.FaceObject.feature)
  
  ::com::sekirocc::face_service::FaceFeature* temp = feature_;
  feature_ = nullptr;
  return temp;
}
inline ::com::sekirocc::face_service::FaceFeature* FaceObject::_internal_mutable_feature() {
  
  if (feature_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::sekirocc::face_service::FaceFeature>(GetArenaForAllocation());
    feature_ = p;
  }
  return feature_;
}
inline ::com::sekirocc::face_service::FaceFeature* FaceObject::mutable_feature() {
  ::com::sekirocc::face_service::FaceFeature* _msg = _internal_mutable_feature();
  // @@protoc_insertion_point(field_mutable:com.sekirocc.face_service.FaceObject.feature)
  return _msg;
}
inline void FaceObject::set_allocated_feature(::com::sekirocc::face_service::FaceFeature* feature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete feature_;
  }
  if (feature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::com::sekirocc::face_service::FaceFeature>::GetOwningArena(feature);
    if (message_arena != submessage_arena) {
      feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature, submessage_arena);
    }
    
  } else {
    
  }
  feature_ = feature;
  // @@protoc_insertion_point(field_set_allocated:com.sekirocc.face_service.FaceObject.feature)
}

// -------------------------------------------------------------------

// ObjectInfo

// .com.sekirocc.face_service.FaceObject face = 1;
inline bool ObjectInfo::_internal_has_face() const {
  return this != internal_default_instance() && face_ != nullptr;
}
inline bool ObjectInfo::has_face() const {
  return _internal_has_face();
}
inline void ObjectInfo::clear_face() {
  if (GetArenaForAllocation() == nullptr && face_ != nullptr) {
    delete face_;
  }
  face_ = nullptr;
}
inline const ::com::sekirocc::face_service::FaceObject& ObjectInfo::_internal_face() const {
  const ::com::sekirocc::face_service::FaceObject* p = face_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::sekirocc::face_service::FaceObject&>(
      ::com::sekirocc::face_service::_FaceObject_default_instance_);
}
inline const ::com::sekirocc::face_service::FaceObject& ObjectInfo::face() const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.ObjectInfo.face)
  return _internal_face();
}
inline void ObjectInfo::unsafe_arena_set_allocated_face(
    ::com::sekirocc::face_service::FaceObject* face) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(face_);
  }
  face_ = face;
  if (face) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.sekirocc.face_service.ObjectInfo.face)
}
inline ::com::sekirocc::face_service::FaceObject* ObjectInfo::release_face() {
  
  ::com::sekirocc::face_service::FaceObject* temp = face_;
  face_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::sekirocc::face_service::FaceObject* ObjectInfo::unsafe_arena_release_face() {
  // @@protoc_insertion_point(field_release:com.sekirocc.face_service.ObjectInfo.face)
  
  ::com::sekirocc::face_service::FaceObject* temp = face_;
  face_ = nullptr;
  return temp;
}
inline ::com::sekirocc::face_service::FaceObject* ObjectInfo::_internal_mutable_face() {
  
  if (face_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::sekirocc::face_service::FaceObject>(GetArenaForAllocation());
    face_ = p;
  }
  return face_;
}
inline ::com::sekirocc::face_service::FaceObject* ObjectInfo::mutable_face() {
  ::com::sekirocc::face_service::FaceObject* _msg = _internal_mutable_face();
  // @@protoc_insertion_point(field_mutable:com.sekirocc.face_service.ObjectInfo.face)
  return _msg;
}
inline void ObjectInfo::set_allocated_face(::com::sekirocc::face_service::FaceObject* face) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete face_;
  }
  if (face) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::com::sekirocc::face_service::FaceObject>::GetOwningArena(face);
    if (message_arena != submessage_arena) {
      face = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, face, submessage_arena);
    }
    
  } else {
    
  }
  face_ = face;
  // @@protoc_insertion_point(field_set_allocated:com.sekirocc.face_service.ObjectInfo.face)
}

// -------------------------------------------------------------------

// FaceDetectResponse

// repeated .com.sekirocc.face_service.ObjectInfo face_info = 1;
inline int FaceDetectResponse::_internal_face_info_size() const {
  return face_info_.size();
}
inline int FaceDetectResponse::face_info_size() const {
  return _internal_face_info_size();
}
inline void FaceDetectResponse::clear_face_info() {
  face_info_.Clear();
}
inline ::com::sekirocc::face_service::ObjectInfo* FaceDetectResponse::mutable_face_info(int index) {
  // @@protoc_insertion_point(field_mutable:com.sekirocc.face_service.FaceDetectResponse.face_info)
  return face_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::ObjectInfo >*
FaceDetectResponse::mutable_face_info() {
  // @@protoc_insertion_point(field_mutable_list:com.sekirocc.face_service.FaceDetectResponse.face_info)
  return &face_info_;
}
inline const ::com::sekirocc::face_service::ObjectInfo& FaceDetectResponse::_internal_face_info(int index) const {
  return face_info_.Get(index);
}
inline const ::com::sekirocc::face_service::ObjectInfo& FaceDetectResponse::face_info(int index) const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.FaceDetectResponse.face_info)
  return _internal_face_info(index);
}
inline ::com::sekirocc::face_service::ObjectInfo* FaceDetectResponse::_internal_add_face_info() {
  return face_info_.Add();
}
inline ::com::sekirocc::face_service::ObjectInfo* FaceDetectResponse::add_face_info() {
  ::com::sekirocc::face_service::ObjectInfo* _add = _internal_add_face_info();
  // @@protoc_insertion_point(field_add:com.sekirocc.face_service.FaceDetectResponse.face_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::ObjectInfo >&
FaceDetectResponse::face_info() const {
  // @@protoc_insertion_point(field_list:com.sekirocc.face_service.FaceDetectResponse.face_info)
  return face_info_;
}

// -------------------------------------------------------------------

// BatchDetectResponse

// repeated .com.sekirocc.face_service.Result results = 1;
inline int BatchDetectResponse::_internal_results_size() const {
  return results_.size();
}
inline int BatchDetectResponse::results_size() const {
  return _internal_results_size();
}
inline void BatchDetectResponse::clear_results() {
  results_.Clear();
}
inline ::com::sekirocc::face_service::Result* BatchDetectResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:com.sekirocc.face_service.BatchDetectResponse.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Result >*
BatchDetectResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:com.sekirocc.face_service.BatchDetectResponse.results)
  return &results_;
}
inline const ::com::sekirocc::face_service::Result& BatchDetectResponse::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::com::sekirocc::face_service::Result& BatchDetectResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.BatchDetectResponse.results)
  return _internal_results(index);
}
inline ::com::sekirocc::face_service::Result* BatchDetectResponse::_internal_add_results() {
  return results_.Add();
}
inline ::com::sekirocc::face_service::Result* BatchDetectResponse::add_results() {
  ::com::sekirocc::face_service::Result* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:com.sekirocc.face_service.BatchDetectResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::Result >&
BatchDetectResponse::results() const {
  // @@protoc_insertion_point(field_list:com.sekirocc.face_service.BatchDetectResponse.results)
  return results_;
}

// repeated .com.sekirocc.face_service.FaceDetectResponse responses = 2;
inline int BatchDetectResponse::_internal_responses_size() const {
  return responses_.size();
}
inline int BatchDetectResponse::responses_size() const {
  return _internal_responses_size();
}
inline void BatchDetectResponse::clear_responses() {
  responses_.Clear();
}
inline ::com::sekirocc::face_service::FaceDetectResponse* BatchDetectResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:com.sekirocc.face_service.BatchDetectResponse.responses)
  return responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::FaceDetectResponse >*
BatchDetectResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:com.sekirocc.face_service.BatchDetectResponse.responses)
  return &responses_;
}
inline const ::com::sekirocc::face_service::FaceDetectResponse& BatchDetectResponse::_internal_responses(int index) const {
  return responses_.Get(index);
}
inline const ::com::sekirocc::face_service::FaceDetectResponse& BatchDetectResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:com.sekirocc.face_service.BatchDetectResponse.responses)
  return _internal_responses(index);
}
inline ::com::sekirocc::face_service::FaceDetectResponse* BatchDetectResponse::_internal_add_responses() {
  return responses_.Add();
}
inline ::com::sekirocc::face_service::FaceDetectResponse* BatchDetectResponse::add_responses() {
  ::com::sekirocc::face_service::FaceDetectResponse* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:com.sekirocc.face_service.BatchDetectResponse.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::sekirocc::face_service::FaceDetectResponse >&
BatchDetectResponse::responses() const {
  // @@protoc_insertion_point(field_list:com.sekirocc.face_service.BatchDetectResponse.responses)
  return responses_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace face_service
}  // namespace sekirocc
}  // namespace com

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::com::sekirocc::face_service::ImageFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::sekirocc::face_service::ImageFormat>() {
  return ::com::sekirocc::face_service::ImageFormat_descriptor();
}
template <> struct is_proto_enum< ::com::sekirocc::face_service::StatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::sekirocc::face_service::StatusCode>() {
  return ::com::sekirocc::face_service::StatusCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pb_2fserver_2eproto
